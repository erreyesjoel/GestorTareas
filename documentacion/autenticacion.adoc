= Backend de Autenticación en Flask: Explicación Paso a Paso

Este documento explica cómo funciona el backend de autenticación en tu proyecto Flask, comparando conceptos con Laravel y detallando el uso de Flask-WTF, Flask-Login y la integración de formularios.

== 1. Estructura General

- Las rutas y la lógica de autenticación están en `app/routes.py`.
- Los formularios se definen en `app/forms.py` usando Flask-WTF.
- El template HTML principal para login y registro es `app/templates/autenticacion.html`.

== 2. Rutas y Lógica Backend

En Flask, las rutas se definen con decoradores como `@main.route('/')`. Cada función asociada a una ruta puede manejar peticiones GET y POST, y contiene la lógica backend (similar a un controller en Laravel).

Ejemplo:
[source,python]
----
@main.route('/', methods=['GET', 'POST'])
def loginRegistro():
    # Si el usuario ya está autenticado, redirige al dashboard
    if current_user.is_authenticated:
        return redirect(url_for('main.dashboard'))

    login_form = LoginForm()
    registro_form = RegistroForm()

    # Lógica de registro
    if registro_form.submit.data and registro_form.validate_on_submit():
        # ...registro de usuario...

    # Lógica de login
    if login_form.submit.data and login_form.validate_on_submit():
        # ...inicio de sesión...

    return render_template('autenticacion.html', 
                         login_form=login_form, 
                         registro_form=registro_form)
----

== 3. Lógica de Registro

- Se crea un objeto `RegistroForm` (definido en `forms.py`).
- Si el usuario envía el formulario de registro y pasa la validación:
  * Se verifica si el email ya existe.
  * Si no existe, se crea un nuevo usuario y se guarda en la base de datos.
  * Se muestra un mensaje de éxito o error.

== 4. Lógica de Login

- Se crea un objeto `LoginForm` (definido en `forms.py`).
- Si el usuario envía el formulario de login y pasa la validación:
  * Se busca el usuario por email.
  * Se verifica la contraseña con `check_password_hash`.
  * Si es correcto, se inicia sesión con `login_user`.
  * Si no, se muestra un mensaje de error.

== 5. ¿Por qué usar Flask-WTF y Flask-Login?

- **Flask-WTF**: Facilita la creación y validación de formularios seguros en Flask. Integra CSRF protection y validadores automáticos.
- **Flask-Login**: Maneja la gestión de sesiones de usuario (login, logout, usuarios autenticados, etc.) de forma sencilla y segura.

== 6. ¿Por qué forms.py?

- En `forms.py` defines las clases de formulario (campos, validaciones, etc.) usando Flask-WTF.
- Esto separa la lógica de los formularios del resto del código, haciéndolo más limpio y mantenible.

Ejemplo:
[source,python]
----
class LoginForm(FlaskForm):
    email = EmailField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Contraseña', validators=[DataRequired()])
    submit = SubmitField('Iniciar Sesión')
----

== 7. ¿Cómo se une con el HTML (`autenticacion.html`)?

- En la función de la ruta, se pasan los objetos `login_form` y `registro_form` al template.
- En el HTML, usas Jinja2 para renderizar los campos del formulario:
+
[source,html]
----
<form method="POST">
    {{ login_form.csrf_token }}
    {{ login_form.email() }}
    {{ login_form.password() }}
    {{ login_form.submit() }}
</form>
----
- Flask-WTF se encarga de enlazar los campos del formulario Python con los inputs HTML, manejar la validación y mostrar errores si los hay.

== 8. ¿Qué es get_flashed_messages y los div class="alert alert-{{ category }}"?

- Flask permite mostrar mensajes temporales (como errores o confirmaciones) usando la función `flash()` en el backend.
- Estos mensajes se recuperan en el template con `get_flashed_messages(with_categories=True)`.
- En el HTML, se suelen mostrar así:
+
[source,html]
----
{% for category, message in get_flashed_messages(with_categories=True) %}
  <div class="alert alert-{{ category }}">
    {{ message }}
  </div>
{% endfor %}
----
- `category` puede ser "success", "error", "warning", etc., y se usa para aplicar estilos CSS diferentes según el tipo de mensaje.
- `message` es el texto que quieres mostrar al usuario.
- **Nota:** Los nombres `category` y `message` en el bucle son variables que tú eliges, igual que en un bucle `for each` en otros lenguajes. Puedes llamarlas como quieras, por ejemplo:
+
[source,html]
----
{% for tipo, texto in get_flashed_messages(with_categories=True) %}
  <div class="alert alert-{{ tipo }}">
    {{ texto }}
  </div>
{% endfor %}
----
- Lo importante es que el primer valor es la categoría y el segundo el mensaje, y los nombres son libres dentro del bucle.

== 9. ¿Qué significan los {{ }} y {% %} en los templates?

- Los archivos `.html` de Flask usan el motor de plantillas Jinja2.
- `{{ variable }}`: Muestra el valor de una variable de Python en el HTML.
- `{% ... %}`: Se usa para lógica de control (bucles, condicionales, bloques, etc.).
- Ejemplo:
+
[source,html]
----
<p>Hola, {{ usuario.nombre }}!</p>
{% if usuario.is_admin %}
  <span>Eres administrador</span>
{% endif %}
----

== 10. ¿Qué es current_user.is_authenticated y de dónde sale?

- La propiedad `current_user.is_authenticated` viene de la extensión **Flask-Login**.
- Cuando importas `from flask_login import current_user`, Flask-Login te da acceso al usuario actual de la sesión.
- El objeto `current_user` representa al usuario que está usando la app en ese momento.
- `is_authenticated` es una propiedad que Flask-Login añade automáticamente a tu modelo de usuario (si hereda de `UserMixin`).
- Así puedes saber si el usuario ha iniciado sesión y controlar el acceso o mostrar contenido según corresponda.
- Ejemplo de uso:
+
[source,python]
----
from flask_login import current_user

if current_user.is_authenticated:
    # El usuario ha iniciado sesión
    ...
else:
    # El usuario no ha iniciado sesión
    ...
----
- Esto es fundamental para proteger rutas, mostrar u ocultar partes de la interfaz, y gestionar la experiencia del usuario.

== 11. Resumen del flujo

1. El usuario accede a `/` y ve el formulario de login/registro.
2. Al enviar un formulario, Flask-WTF valida los datos.
3. Si es registro, se crea el usuario; si es login, se verifica y autentica.
4. Flask-Login gestiona la sesión del usuario.
5. El usuario es redirigido según corresponda.
6. Los mensajes flash se muestran en el HTML usando `get_flashed_messages`.
7. Puedes saber si el usuario está autenticado usando `current_user.is_authenticated`.

== 12. Ventajas de este enfoque

- Seguridad (CSRF, validaciones, gestión de sesiones)
- Código organizado y mantenible
- Separación clara entre lógica, formularios y vistas
- Feedback visual inmediato al usuario con mensajes flash
- Control total sobre la autenticación y el acceso de usuarios

== 13. Recursos útiles

- https://flask-wtf.readthedocs.io/
- https://flask-login.readthedocs.io/
- https://flask.palletsprojects.com/
